#!/usr/bin/env python3
"""
Post-processing module for Perl to Python converter.

This module provides functions to clean up and enhance the Python code
generated by the Perl to Python converter.
"""

import re
import os
import sys
import logging
from typing import Dict, List, Optional, Tuple, Union

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def post_process_python_code(python_code: str) -> str:
    """
    Apply post-processing fixes to the generated Python code.
    
    Args:
        python_code: The Python code generated by the converter
        
    Returns:
        Enhanced Python code with fixes applied
    """
    # Apply fixes in sequence
    python_code = fix_looks_like_number(python_code)
    python_code = fix_defined_syntax(python_code)
    python_code = fix_ref_function(python_code)
    python_code = fix_numeric_operations(python_code)
    python_code = fix_string_interpolation(python_code)
    python_code = fix_module_imports(python_code)
    python_code = fix_unless_conditions(python_code)
    python_code = fix_indentation_issues(python_code)
    
    return python_code

def fix_looks_like_number(python_code: str) -> str:
    """
    Add implementation of Perl's looks_like_number function if it's used in the code.
    
    Args:
        python_code: The Python code to fix
        
    Returns:
        Python code with looks_like_number implementation added if needed
    """
    if "looks_like_number" in python_code and "def looks_like_number" not in python_code:
        # Add the implementation after the imports but before the code
        looks_like_number_impl = """
# Implementation of Perl's looks_like_number function
def looks_like_number(s):
    try:
        float(s)
        return True
    except (ValueError, TypeError):
        return False
"""
        # Find a good place to insert the implementation
        import_section_end = python_code.find("if __name__ == '__main__':")
        if import_section_end == -1:
            # If there's no main guard, insert after the last import or at the beginning
            last_import = max(python_code.rfind("import "), python_code.rfind("from "))
            if last_import != -1:
                # Find the end of the line with the last import
                last_import_end = python_code.find("\n", last_import)
                if last_import_end != -1:
                    insert_pos = last_import_end + 1
                else:
                    insert_pos = len(python_code)
            else:
                # No imports found, insert after the header comments
                header_end = python_code.find("\n\n")
                insert_pos = header_end + 2 if header_end != -1 else 0
        else:
            # Insert before the main guard
            insert_pos = import_section_end
            
        python_code = python_code[:insert_pos] + looks_like_number_impl + python_code[insert_pos:]
    
    return python_code

def fix_defined_syntax(python_code: str) -> str:
    """
    Fix incorrect 'defined' syntax in the Python code.
    
    Args:
        python_code: The Python code to fix
        
    Returns:
        Python code with defined syntax fixed
    """
    # Fix the "defi!=d" syntax error
    python_code = re.sub(r'defi!=d\s+(\w+)', r'\1 is not None', python_code)
    
    return python_code

def fix_ref_function(python_code: str) -> str:
    """
    Add implementation of Perl's ref function if it's used in the code.
    
    Args:
        python_code: The Python code to fix
        
    Returns:
        Python code with ref function implementation added if needed
    """
    if "ref(" in python_code and "def ref(" not in python_code:
        # Add the implementation after the imports but before the code
        ref_impl = """
# Implementation of Perl's ref function
def ref(obj):
    if obj is None:
        return ""
    elif isinstance(obj, list):
        return "ARRAY"
    elif isinstance(obj, dict):
        return "HASH"
    elif callable(obj):
        return "CODE"
    elif hasattr(obj, '__dict__'):
        return "OBJECT"
    else:
        return ""
"""
        # Find a good place to insert the implementation
        import_section_end = python_code.find("if __name__ == '__main__':")
        if import_section_end == -1:
            # If there's no main guard, insert after the last import or at the beginning
            last_import = max(python_code.rfind("import "), python_code.rfind("from "))
            if last_import != -1:
                # Find the end of the line with the last import
                last_import_end = python_code.find("\n", last_import)
                if last_import_end != -1:
                    insert_pos = last_import_end + 1
                else:
                    insert_pos = len(python_code)
            else:
                # No imports found, insert after the header comments
                header_end = python_code.find("\n\n")
                insert_pos = header_end + 2 if header_end != -1 else 0
        else:
            # Insert before the main guard
            insert_pos = import_section_end
            
        python_code = python_code[:insert_pos] + ref_impl + python_code[insert_pos:]
    
    return python_code

def fix_numeric_operations(python_code: str) -> str:
    """
    Fix numeric operations to ensure proper type conversion.
    
    Args:
        python_code: The Python code to fix
        
    Returns:
        Python code with numeric operations fixed
    """
    # Find lines with numeric operations
    lines = python_code.split('\n')
    for i, line in enumerate(lines):
        # Look for addition, subtraction, multiplication, division
        if re.search(r'=\s*\w+\s*[\+\-\*\/]\s*\w+', line):
            # Check if it's a numeric operation (not string concatenation)
            if "sum" in line or re.search(r'[\+\-\*\/]\s*\d+', line) or re.search(r'\d+\s*[\+\-\*\/]', line):
                # Add float() conversion to variables
                line = re.sub(r'(\w+)\s*([\+\-\*\/])\s*(\w+)', r'float(\1) \2 float(\3)', line)
                lines[i] = line
    
    return '\n'.join(lines)

def fix_string_interpolation(python_code: str) -> str:
    """
    Fix string interpolation issues in print statements.
    
    Args:
        python_code: The Python code to fix
        
    Returns:
        Python code with string interpolation fixed
    """
    # Fix double curly braces in f-strings
    python_code = re.sub(r'print\(f"([^"]*)\{\{(\w+)\}\}([^"]*)"', r'print(f"\1{\2}\3"', python_code)
    
    return python_code

def fix_module_imports(python_code: str) -> str:
    """
    Fix module imports and add proper Python equivalents for Perl modules.
    
    Args:
        python_code: The Python code to fix
        
    Returns:
        Python code with module imports fixed
    """
    # Replace TODO comments with actual imports
    if "# TODO: Import equivalent for Perl module 'FindBin'" in python_code:
        python_code = python_code.replace(
            "# TODO: Import equivalent for Perl module 'FindBin'",
            "import os\nimport sys"
        )
    
    if "# TODO: Import equivalent for Perl module 'lib'" in python_code:
        python_code = python_code.replace(
            "# TODO: Import equivalent for Perl module 'lib'",
            "# Add current directory to module search path\nsys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))"
        )
    
    if "# TODO: Import equivalent for Perl module 'StringUtils'" in python_code:
        python_code = python_code.replace(
            "# TODO: Import equivalent for Perl module 'StringUtils'",
            "from StringUtils import to_uppercase"
        )
    
    if "# TODO: Import equivalent for Perl module 'Scalar::Util'" in python_code:
        python_code = python_code.replace(
            "# TODO: Import equivalent for Perl module 'Scalar::Util'",
            "# Scalar::Util functions implemented inline"
        )
    
    if "# TODO: Import equivalent for Perl module 'Exporter'" in python_code:
        python_code = python_code.replace(
            "# TODO: Import equivalent for Perl module 'Exporter'",
            "# Python doesn't need Exporter, modules export all symbols by default"
        )
    
    return python_code

def fix_unless_conditions(python_code: str) -> str:
    """
    Fix unless conditions that were incorrectly converted.
    
    Args:
        python_code: The Python code to fix
        
    Returns:
        Python code with unless conditions fixed
    """
    # Find lines with unconditional raise that should be conditional
    lines = python_code.split('\n')
    for i, line in enumerate(lines):
        if "# Check if input is defined" in line and i+1 < len(lines) and "raise Exception" in lines[i+1]:
            # This is likely an unless condition that was incorrectly converted
            lines[i+1] = lines[i+1].replace("raise Exception", "if input is None:\n        raise Exception")
    
    return '\n'.join(lines)

def fix_indentation_issues(python_code: str) -> str:
    """
    Fix indentation issues in the Python code.
    
    Args:
        python_code: The Python code to fix
        
    Returns:
        Python code with indentation fixed
    """
    # Fix indentation issues in the code
    lines = python_code.split('\n')
    fixed_lines = []
    current_indent = 0
    
    for i, line in enumerate(lines):
        stripped = line.strip()
        
        # Skip empty lines
        if not stripped:
            fixed_lines.append('')
            continue
        
        # Handle indentation for control structures
        if stripped.startswith('def ') or stripped.startswith('if ') or stripped.startswith('elif ') or stripped.startswith('else:') or stripped.startswith('try:') or stripped.startswith('except ') or stripped.startswith('finally:') or stripped.startswith('for ') or stripped.startswith('while '):
            # This is a control structure, add it with current indentation
            fixed_lines.append(' ' * current_indent + stripped)
            current_indent += 4
            continue
        
        # Handle end of control structures
        if current_indent >= 4 and (i+1 < len(lines) and lines[i+1].strip() and len(lines[i+1]) - len(lines[i+1].lstrip()) < current_indent):
            # Next line has less indentation, reduce current indentation
            current_indent -= 4
        
        # Add the line with current indentation
        fixed_lines.append(' ' * current_indent + stripped)
    
    return '\n'.join(fixed_lines)

def post_process_file(input_file: str, output_file: Optional[str] = None) -> str:
    """
    Apply post-processing to a Python file.
    
    Args:
        input_file: Path to the input Python file
        output_file: Optional path to save the processed Python code
        
    Returns:
        The processed Python code as a string
    """
    if not os.path.exists(input_file):
        raise FileNotFoundError(f"Input file not found: {input_file}")
    
    logger.info(f"Post-processing Python file: {input_file}")
    
    with open(input_file, 'r', encoding='utf-8') as f:
        python_code = f.read()
    
    processed_code = post_process_python_code(python_code)
    
    if output_file:
        os.makedirs(os.path.dirname(os.path.abspath(output_file)), exist_ok=True)
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(processed_code)
        logger.info(f"Processed Python code saved to: {output_file}")
    
    return processed_code

if __name__ == '__main__':
    # Simple command-line interface
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} input_file [output_file]")
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else None
    
    try:
        post_process_file(input_file, output_file)
    except Exception as e:
        logger.error(f"Error post-processing file: {e}")
        sys.exit(1)