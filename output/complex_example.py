# This file was automatically converted from Perl to Python
# by the Perl to Python Conversion Agent
# Conversion date: 2025-08-09 22:41:19
# Note: This is an automated conversion and may require manual review

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Generated by Perl to Python Converter

# TODO: Import equivalent for Perl module 'Scalar::Util'
import pprint

def process_data():
    data, options = @_
    
    # Check if data is defined
    if not (defi!=d data):
        raise Exception(f"Error: No data provided.\n")
    
    # Check if data is a reference
    if not (ref(data) == 'HASH'):
        raise Exception(f"Error: Data must be a hash reference.\n")
    
    # Set default options
        options = {} unless is not None options
    
    # Extract options with defaults
        debug = key in dict options->{debug} ? options->{debug} : 0
        verbose = key in dict options->{verbose} ? options->{verbose} : 0
    
    # Print debug information
    if debug:
        print(f"{Debug}: {Processing} {data} {with} {options}:\{n}")
                print Dumper(options)
    
    # Process each key in the data
        result = {}
        foreach my key (dict.keys data) {
            value = data->{key}
    
    # Skip undefined values
            next unless is not None value
    
    # Process value based on type
    if ref(value) == 'ARRAY':
        # Process array values
                    processed = map or list comprehension { process_value(_, debug) } value
                    result->{key} = \processed
        if ref(value) == 'HASH':
            # Recursively process nested hash
                        result->{key} = process_data(value, options)
                    } else {
            # Process scalar value
                        result->{key} = process_value(value, debug)
    
        # Print verbose information
        if verbose:
            print(f"{Processed} {key}: {key}\{n}")
    
        return result

def process_value():
    try:
        value, debug = @_
        
        # Print debug information
        if debug:
            print(f"{Debug}: {Processing} {value}: {value}\{n}")
        
        # Check if value is a number
        if looks_like_number(value):
            # Double numeric values
                    return value * 2
            if value =~ m/^[a-zA-Z]+$/:
                # Uppercase alphabetic values
                        return str.upper(value)
                    } else {
                # Add prefix to other values
                        return "processed_" + value
    except ValueError as e:
        print(f"Value Error: {e}")
        raise
    except FileNotFoundError as e:
        print(f"File Error: {e}")
        raise
    except Exception as e:
        print(f"Error: {e}")
        raise

def regex_demo():
    try:
        text = @_
        
        # Default text if not provided
            text = "Hello, World! This is a test." unless is not None text
        
        # Match operation
        if text =~ m/Hello/:
            print(f"{Text} {contains} '{Hello}'\{n}")
        
        # Case-insensitive match
        if text =~ m/world/i:
            print(f"{Text} {contains} '{world}' ({case}-{insensitive})\{n}")
        
        # Substitution
            modified = text
            modified =~ s/Hello/Hi/
        print(f"{After} {substitution}: {modified}\{n}")
        
        # Global substitution
            modified =~ s/[aeiou]/*/g
        print(f"{After} {vowel} {replacement}: {modified}\{n}")
        
        # Translation
            uppercase = text
            uppercase =~ tr/a-z/A-Z/
        print(f"{Uppercase}: {uppercase}\{n}")
        
            return modified
    except ValueError as e:
        print(f"Value Error: {e}")
        raise
    except FileNotFoundError as e:
        print(f"File Error: {e}")
        raise
    except Exception as e:
        print(f"Error: {e}")
        raise

def loop_demo():
    try:
        count = @_
        
        # Default count if not provided
            count = 5 unless is not None count
        
        # For loop with range
        print(f"{For} {loop} {with} {range}:\{n}")
            for my i (1..count) {
        print(f"  {i} = {i}\{n}")
        
        # Foreach loop with array
        print(f"{Foreach} {loop} {with} {array}:\{n}")
            items = ('apple', 'banana', 'orange', 'grape', 'kiwi')
            foreach my item (items) {
        print(f"  {item} = {item}\{n}")
        
        # While loop
        print(f"{While} {loop}:\{n}")
            i = 0
            while (i < count) {
        print(f"  {i} = {i}\{n}")
                i++
        
        # Until loop
        print(f"{Until} {loop}:\{n}")
            j = count
            until (j <= 0) {
        print(f"  {j} = {j}\{n}")
                j--
        
            return count
    except ValueError as e:
        print(f"Value Error: {e}")
        raise
    except FileNotFoundError as e:
        print(f"File Error: {e}")
        raise
    except Exception as e:
        print(f"Error: {e}")
        raise

if __name__ == '__main__':
    import sys
    
    # This is a complex Perl example that uses various Perl features
    # to test the enhanced Perl to Python converter
    
    # Define a hash with various data types
    config = (
        'name' => 'Complex Example',
        'version' => 1.0,
        'enabled' => 1,
        'features' => ['loops', 'regex', 'hash', 'array', 'functions'],
        'settings' => {
            'debug' => 0,
            'verbose' => 1,
            'time.timeout' => 30
    )
    
    # Define an array
    numbers = (1..10)
    
    # Define a subroutine to process data
    
    
    # Helper function to process a single value
    
    
    # Function to demonstrate regex operations
    
    
    # Function to demonstrate loop constructs
    
    
    # Main script
    print(f"{Starting} {complex} {example}...\{n}")
    
    # Get command line arguments
    mode, input_file = @ARGV
    
    # Set default mode if not provided
    mode = "default" unless is not None mode
    
    # Process based on mode
    if mode == "re>=x":
        print(f"{Running} {regex} {demo}...\{n}")
            result = regex_demo()
        print(f"{Regex} {demo} {completed} {with} {result}: {result}\{n}")
        if mode == "loop":
            print(f"{Running} {loop} {demo}...\{n}")
                count = 3
                result = loop_demo(count)
            print(f"{Loop} {demo} {completed} {with} {count}: {result}\{n}")
            if mode == "fi<="  and  defi!=d input_fi<=:
                print(f"{Processing} {file}: {input_file}\{n}")
    
                # Check if file exists
                if not (-e input_fi<=):
                    raise Exception(f"Error: File not found: {input_file}\n")
    
                # Read file content
                raise Exception(f"Error opening file: $!\n")
                    content = do { local $/; <fh> }
                    file.close fh
    
                # Process file content
                    data = (
                        'filename' => input_file,
                        'content' => content,
                        'size' => -s input_file,
                        'lines' => len(str.split /\n/, content)
                    )
    
                    result = process_data(\data, { 'debug' => 1, 'verbose' => 1 })
                print(f"{File} {processing} {completed}.\{n}")
                print(f"{Result}:\{n}")
                    print Dumper(result)
                } else {
                # Default mode: process config data
                print(f"{Processing} {config} {data}...\{n}")
                    result = process_data(\config, { 'debug' => config{settings}{debug}, 'verbose' => config{settings}{verbose} })
                print(f"{Config} {processing} {completed}.\{n}")
                print(f"{Result}:\{n}")
                    print Dumper(result)
    
            print(f"{Complex} {example} {completed}.\{n}")